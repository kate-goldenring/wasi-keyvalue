/// A keyvalue interface that provides eventually consistent CRUD operations.
/// 
/// A CRUD operation is an operation that acts on a single key-value pair.
/// 
/// The value in the key-value pair is defined as a `u8` byte array and the intention is that it is
/// the common denominator for all data types defined by different key-value stores to handle data,
/// ensuring compatibility between different key-value stores. Note: the clients will be expecting
/// serialization/deserialization overhead to be handled by the key-value store. The value could be
/// a serialized object from JSON, HTML or vendor-specific data types like AWS S3 objects.
///
/// This interface provides **eventual consistency** plus a read-your-writes guarantee. This means
/// that the value written to a given key on a given `crud` instance will be immediately available
/// to read using that same `crud` instance, but not necessarily via other `crud` instances (which
/// might be connected to other nodes in a distributed system).  The "eventual" aspect means that if
/// we pause the updates to the system, the system eventually will return the last updated value for
/// read (where "last updated" is implementation-defined and might not be based on wall clock time).
///
/// For example, consider the following pseudo-code, and assume no other updates are happening
/// concurrently:
///
///   s1 = Store.get("foo")
///   c1 = Crud.open(s1)
///   s2 = Store.get("foo")
///   c2 = Crud.open(s2)
///   c1.set("a", b"x")
///   assert(c1.get("a") == b"x") // guaranteed to succeed
///   assert(c2.get("a") == b"x") // NOT guaranteed to succeed
///   sleep_seconds(60) // assume this is long enough for system to reach consistency
///   assert(c2.get("a") == b"x") // guaranteed to succeed if system has reached consistency
///
/// In distributed systems terminology, this interface guarantees neither [linearizability nor
/// serializability](http://www.bailis.org/blog/linearizability-versus-serializability/). Practically
/// speaking, that means that:
///
///   - Distinct `crud` instances may see writes occur in different orders.
///   - The last write to a given key from a wall clock perspective might not be the one the system
///     converges on.
///   - Values retrieved for more than one key are not guaranteed to be consistent with each other
///     from an application perspective.
///   - There's no way (using this interface alone) to apply transactional operations on single or
///     multiple values.
interface key-value {
  use types.{store, error};
  
  /// The crud resource contains the common create, read, update, and delete operations for
  /// key-value pairs in a key-value store
  resource crud {
    /// Create a new crud resource, using the given store to access the data
	  open: static func(store: borrow<store>) -> crud;

    /// Get the value associated with the specified `key`
    ///
    /// The value is returned as an option. If the key-value pair exists in the
    /// store, it returns `Ok(value)`. If the key does not exist in the
    /// store, it returns `Ok(none)`. 
    ///
    /// If any other error occurs, it returns an `Err(error)`.
    get: func(key: string) -> result<option<list<u8>>, error>;

    /// Set the value associated with the key in the store. If the key already
    /// exists in the store, it overwrites the value.
    ///
    /// If the key does not exist in the store, it creates a new key-value pair.
    /// 
    /// If any other error occurs, it returns an `Err(error)`.
    set: func(key: string, value: list<u8>) -> result<_, error>;

    /// Delete the key-value pair associated with the key in the store.
    /// 
    /// If the key does not exist in the store, it does nothing.
    ///
    /// If any other error occurs, it returns an `Err(error)`.
    delete: func(key: string) -> result<_, error>;

    /// Check if the key exists in the store.
    /// 
    /// If the key exists in the store, it returns `Ok(true)`. If the key does
    /// not exist in the store, it returns `Ok(false)`.
    /// 
    /// If any other error occurs, it returns an `Err(error)`.
    exists: func(key: string) -> result<bool, error>;

    /// Get all the keys in the store. It returns a list of keys.
    /// 
    /// Note that the keys are not guaranteed to be returned in any particular order.
    /// 
    /// If the store is empty, it returns an empty list.
    /// 
    /// MAY show an out-of-date list of keys if there are concurrent writes to the store.
    /// 
    /// If any error occurs, it returns an `Err(error)`.
    list-keys: func() -> result<list<string>, error>;
  }
}
