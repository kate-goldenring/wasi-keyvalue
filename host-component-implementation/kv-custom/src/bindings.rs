// Generated by `wit-bindgen` 0.16.0. DO NOT EDIT!
const _: () = {
    #[doc(hidden)]
    #[export_name = "doing"]
    #[allow(non_snake_case)]
    unsafe extern "C" fn __export_doing(arg0: i32, arg1: i32) -> i32 {
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, string::String, vec::Vec};

        // Before executing any other code, use this function to run all static
        // constructors, if they have not yet been run. This is a hack required
        // to work around wasi-libc ctors calling import functions to initialize
        // the environment.
        //
        // This functionality will be removed once rust 1.69.0 is stable, at which
        // point wasi-libc will no longer have this behavior.
        //
        // See
        // https://github.com/bytecodealliance/preview2-prototyping/issues/99
        // for more details.
        #[cfg(target_arch = "wasm32")]
        wit_bindgen::rt::run_ctors_once();

        let len0 = arg1 as usize;
        let bytes0 = Vec::from_raw_parts(arg0 as *mut _, len0, len0);
        let result1 = <_GuestImpl as Guest>::doing(wit_bindgen::rt::string_lift(bytes0));
        let ptr2 = _RET_AREA.0.as_mut_ptr() as i32;
        let vec3 = (result1.into_bytes()).into_boxed_slice();
        let ptr3 = vec3.as_ptr() as i32;
        let len3 = vec3.len() as i32;
        ::core::mem::forget(vec3);
        *((ptr2 + 4) as *mut i32) = len3;
        *((ptr2 + 0) as *mut i32) = ptr3;
        ptr2
    }

    const _: () = {
        #[doc(hidden)]
        #[export_name = "cabi_post_doing"]
        #[allow(non_snake_case)]
        unsafe extern "C" fn __post_return_doing(arg0: i32) {
            let l0 = *((arg0 + 0) as *const i32);
            let l1 = *((arg0 + 4) as *const i32);
            wit_bindgen::rt::dealloc(l0, (l1) as usize, 1);
        }
    };
};
use super::Component as _GuestImpl;
pub trait Guest {
    fn doing(input: wit_bindgen::rt::string::String) -> wit_bindgen::rt::string::String;
}

#[allow(unused_imports)]
use wit_bindgen::rt::{alloc, string::String, vec::Vec};

#[repr(align(4))]
struct _RetArea([u8; 8]);
static mut _RET_AREA: _RetArea = _RetArea([0; 8]);
pub mod wasi {
    pub mod keyvalue {

        #[allow(clippy::all)]
        pub mod types {
            #[used]
            #[doc(hidden)]
            #[cfg(target_arch = "wasm32")]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
            /// A bucket is a collection of key-value pairs. Each key-value pair is stored as a entry in the
            /// bucket, and the bucket itself acts as a collection of all these entries.
            ///
            /// It is worth noting that the exact terminology for bucket in key-value stores can very
            /// depending on the specific implementation. For example:
            ///
            /// 1. Amazon DynamoDB calls a collection of key-value pairs a table
            /// 2. Redis has hashes, sets, and sorted sets as different types of collections
            /// 3. Cassandra calls a collection of key-value pairs a column family
            /// 4. MongoDB calls a collection of key-value pairs a collection
            /// 5. Riak calls a collection of key-value pairs a bucket
            /// 6. Memcached calls a collection of key-value pairs a slab
            /// 7. Azure Cosmos DB calls a collection of key-value pairs a container
            ///
            /// In this interface, we use the term `bucket` to refer to a collection of key-value pairs

            #[derive(Debug)]
            #[repr(transparent)]
            pub struct Store {
                handle: wit_bindgen::rt::Resource<Store>,
            }

            impl Store {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: wit_bindgen::rt::Resource::from_handle(handle),
                    }
                }

                #[doc(hidden)]
                pub fn into_handle(self) -> u32 {
                    wit_bindgen::rt::Resource::into_handle(self.handle)
                }

                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    wit_bindgen::rt::Resource::handle(&self.handle)
                }
            }

            unsafe impl wit_bindgen::rt::WasmResource for Store {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();

                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(wasm_import_module = "wasi:keyvalue/types@0.1.0")]
                        extern "C" {
                            #[link_name = "[resource-drop]store"]
                            fn drop(_: u32);
                        }

                        drop(_handle);
                    }
                }
            }

            /// The set of errors which may be raised by functions in this interface
            #[derive(Clone)]
            pub enum Error {
                /// The host does not recognize the store identifier requested.
                NoSuchStore,
                /// The requesting component does not have access to the specified store
                /// (which may or may not exist).
                AccessDenied,
                /// Some implementation-specific error has occurred (e.g. I/O)
                Other(wit_bindgen::rt::string::String),
            }
            impl ::core::fmt::Debug for Error {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    match self {
                        Error::NoSuchStore => f.debug_tuple("Error::NoSuchStore").finish(),
                        Error::AccessDenied => f.debug_tuple("Error::AccessDenied").finish(),
                        Error::Other(e) => f.debug_tuple("Error::Other").field(e).finish(),
                    }
                }
            }
            impl ::core::fmt::Display for Error {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    write!(f, "{:?}", self)
                }
            }

            impl std::error::Error for Error {}
            impl Store {
                #[allow(unused_unsafe, clippy::all)]
                /// Get the store with the specified identifier.
                ///
                /// `identifier` must refer to a store provided by the host.
                ///
                /// `error::no-such-store` will be raised if the `identifier` is not recognized.
                pub fn get(identifier: &str) -> Result<Store, Error> {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, string::String, vec::Vec};
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([u8; 16]);
                        let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                        let vec0 = identifier;
                        let ptr0 = vec0.as_ptr() as i32;
                        let len0 = vec0.len() as i32;
                        let ptr1 = ret_area.as_mut_ptr() as i32;
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:keyvalue/types@0.1.0")]
                        extern "C" {
                            #[link_name = "[static]store.get"]
                            fn wit_import(_: i32, _: i32, _: i32);
                        }

                        #[cfg(not(target_arch = "wasm32"))]
                        fn wit_import(_: i32, _: i32, _: i32) {
                            unreachable!()
                        }
                        wit_import(ptr0, len0, ptr1);
                        let l2 = i32::from(*((ptr1 + 0) as *const u8));
                        match l2 {
                            0 => {
                                let e = {
                                    let l3 = *((ptr1 + 4) as *const i32);

                                    Store::from_handle(l3 as u32)
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*((ptr1 + 4) as *const u8));
                                    let v8 = match l4 {
                                        0 => Error::NoSuchStore,
                                        1 => Error::AccessDenied,
                                        n => {
                                            debug_assert_eq!(n, 2, "invalid enum discriminant");
                                            let e8 = {
                                                let l5 = *((ptr1 + 8) as *const i32);
                                                let l6 = *((ptr1 + 12) as *const i32);
                                                let len7 = l6 as usize;
                                                let bytes7 =
                                                    Vec::from_raw_parts(l5 as *mut _, len7, len7);

                                                wit_bindgen::rt::string_lift(bytes7)
                                            };
                                            Error::Other(e8)
                                        }
                                    };

                                    v8
                                };
                                Err(e)
                            }
                            _ => wit_bindgen::rt::invalid_enum_discriminant(),
                        }
                    }
                }
            }
        }

        #[allow(clippy::all)]
        pub mod crud {
            #[used]
            #[doc(hidden)]
            #[cfg(target_arch = "wasm32")]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
            pub type Store = super::super::super::wasi::keyvalue::types::Store;
            pub type Error = super::super::super::wasi::keyvalue::types::Error;
            /// The crud resource contains the common create, read, update, and delete operations for
            /// key-value pairs in a key-value store

            #[derive(Debug)]
            #[repr(transparent)]
            pub struct Crud {
                handle: wit_bindgen::rt::Resource<Crud>,
            }

            impl Crud {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: wit_bindgen::rt::Resource::from_handle(handle),
                    }
                }

                #[doc(hidden)]
                pub fn into_handle(self) -> u32 {
                    wit_bindgen::rt::Resource::into_handle(self.handle)
                }

                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    wit_bindgen::rt::Resource::handle(&self.handle)
                }
            }

            unsafe impl wit_bindgen::rt::WasmResource for Crud {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();

                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(wasm_import_module = "wasi:keyvalue/crud@0.1.0")]
                        extern "C" {
                            #[link_name = "[resource-drop]crud"]
                            fn drop(_: u32);
                        }

                        drop(_handle);
                    }
                }
            }

            impl Crud {
                #[allow(unused_unsafe, clippy::all)]
                /// Create a new crud resource, using the given store to access the data
                pub fn open(store: &Store) -> Crud {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, string::String, vec::Vec};
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:keyvalue/crud@0.1.0")]
                        extern "C" {
                            #[link_name = "[static]crud.open"]
                            fn wit_import(_: i32) -> i32;
                        }

                        #[cfg(not(target_arch = "wasm32"))]
                        fn wit_import(_: i32) -> i32 {
                            unreachable!()
                        }
                        let ret = wit_import((store).handle() as i32);
                        Crud::from_handle(ret as u32)
                    }
                }
            }
            impl Crud {
                #[allow(unused_unsafe, clippy::all)]
                /// Get the value associated with the specified `key`
                ///
                /// The value is returned as an option. If the key-value pair exists in the
                /// store, it returns `Ok(value)`. If the key does not exist in the
                /// store, it returns `Ok(none)`.
                ///
                /// If any other error occurs, it returns an `Err(error)`.
                pub fn get(
                    &self,
                    key: &str,
                ) -> Result<Option<wit_bindgen::rt::vec::Vec<u8>>, Error> {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, string::String, vec::Vec};
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([u8; 16]);
                        let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                        let vec0 = key;
                        let ptr0 = vec0.as_ptr() as i32;
                        let len0 = vec0.len() as i32;
                        let ptr1 = ret_area.as_mut_ptr() as i32;
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:keyvalue/crud@0.1.0")]
                        extern "C" {
                            #[link_name = "[method]crud.get"]
                            fn wit_import(_: i32, _: i32, _: i32, _: i32);
                        }

                        #[cfg(not(target_arch = "wasm32"))]
                        fn wit_import(_: i32, _: i32, _: i32, _: i32) {
                            unreachable!()
                        }
                        wit_import((self).handle() as i32, ptr0, len0, ptr1);
                        let l2 = i32::from(*((ptr1 + 0) as *const u8));
                        match l2 {
                            0 => {
                                let e = {
                                    let l3 = i32::from(*((ptr1 + 4) as *const u8));

                                    match l3 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l4 = *((ptr1 + 8) as *const i32);
                                                let l5 = *((ptr1 + 12) as *const i32);
                                                let len6 = l5 as usize;

                                                Vec::from_raw_parts(l4 as *mut _, len6, len6)
                                            };
                                            Some(e)
                                        }
                                        _ => wit_bindgen::rt::invalid_enum_discriminant(),
                                    }
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l7 = i32::from(*((ptr1 + 4) as *const u8));
                                    use super::super::super::wasi::keyvalue::types::Error as V11;
                                    let v11 = match l7 {
                                        0 => V11::NoSuchStore,
                                        1 => V11::AccessDenied,
                                        n => {
                                            debug_assert_eq!(n, 2, "invalid enum discriminant");
                                            let e11 = {
                                                let l8 = *((ptr1 + 8) as *const i32);
                                                let l9 = *((ptr1 + 12) as *const i32);
                                                let len10 = l9 as usize;
                                                let bytes10 =
                                                    Vec::from_raw_parts(l8 as *mut _, len10, len10);

                                                wit_bindgen::rt::string_lift(bytes10)
                                            };
                                            V11::Other(e11)
                                        }
                                    };

                                    v11
                                };
                                Err(e)
                            }
                            _ => wit_bindgen::rt::invalid_enum_discriminant(),
                        }
                    }
                }
            }
            impl Crud {
                #[allow(unused_unsafe, clippy::all)]
                /// Set the value associated with the key in the store. If the key already
                /// exists in the store, it overwrites the value.
                ///
                /// If the key does not exist in the store, it creates a new key-value pair.
                ///
                /// If any other error occurs, it returns an `Err(error)`.
                pub fn set(&self, key: &str, value: &[u8]) -> Result<(), Error> {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, string::String, vec::Vec};
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([u8; 16]);
                        let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                        let vec0 = key;
                        let ptr0 = vec0.as_ptr() as i32;
                        let len0 = vec0.len() as i32;
                        let vec1 = value;
                        let ptr1 = vec1.as_ptr() as i32;
                        let len1 = vec1.len() as i32;
                        let ptr2 = ret_area.as_mut_ptr() as i32;
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:keyvalue/crud@0.1.0")]
                        extern "C" {
                            #[link_name = "[method]crud.set"]
                            fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32);
                        }

                        #[cfg(not(target_arch = "wasm32"))]
                        fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32) {
                            unreachable!()
                        }
                        wit_import((self).handle() as i32, ptr0, len0, ptr1, len1, ptr2);
                        let l3 = i32::from(*((ptr2 + 0) as *const u8));
                        match l3 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*((ptr2 + 4) as *const u8));
                                    use super::super::super::wasi::keyvalue::types::Error as V8;
                                    let v8 = match l4 {
                                        0 => V8::NoSuchStore,
                                        1 => V8::AccessDenied,
                                        n => {
                                            debug_assert_eq!(n, 2, "invalid enum discriminant");
                                            let e8 = {
                                                let l5 = *((ptr2 + 8) as *const i32);
                                                let l6 = *((ptr2 + 12) as *const i32);
                                                let len7 = l6 as usize;
                                                let bytes7 =
                                                    Vec::from_raw_parts(l5 as *mut _, len7, len7);

                                                wit_bindgen::rt::string_lift(bytes7)
                                            };
                                            V8::Other(e8)
                                        }
                                    };

                                    v8
                                };
                                Err(e)
                            }
                            _ => wit_bindgen::rt::invalid_enum_discriminant(),
                        }
                    }
                }
            }
            impl Crud {
                #[allow(unused_unsafe, clippy::all)]
                /// Delete the key-value pair associated with the key in the store.
                ///
                /// If the key does not exist in the store, it does nothing.
                ///
                /// If any other error occurs, it returns an `Err(error)`.
                pub fn delete(&self, key: &str) -> Result<(), Error> {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, string::String, vec::Vec};
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([u8; 16]);
                        let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                        let vec0 = key;
                        let ptr0 = vec0.as_ptr() as i32;
                        let len0 = vec0.len() as i32;
                        let ptr1 = ret_area.as_mut_ptr() as i32;
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:keyvalue/crud@0.1.0")]
                        extern "C" {
                            #[link_name = "[method]crud.delete"]
                            fn wit_import(_: i32, _: i32, _: i32, _: i32);
                        }

                        #[cfg(not(target_arch = "wasm32"))]
                        fn wit_import(_: i32, _: i32, _: i32, _: i32) {
                            unreachable!()
                        }
                        wit_import((self).handle() as i32, ptr0, len0, ptr1);
                        let l2 = i32::from(*((ptr1 + 0) as *const u8));
                        match l2 {
                            0 => {
                                let e = ();
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l3 = i32::from(*((ptr1 + 4) as *const u8));
                                    use super::super::super::wasi::keyvalue::types::Error as V7;
                                    let v7 = match l3 {
                                        0 => V7::NoSuchStore,
                                        1 => V7::AccessDenied,
                                        n => {
                                            debug_assert_eq!(n, 2, "invalid enum discriminant");
                                            let e7 = {
                                                let l4 = *((ptr1 + 8) as *const i32);
                                                let l5 = *((ptr1 + 12) as *const i32);
                                                let len6 = l5 as usize;
                                                let bytes6 =
                                                    Vec::from_raw_parts(l4 as *mut _, len6, len6);

                                                wit_bindgen::rt::string_lift(bytes6)
                                            };
                                            V7::Other(e7)
                                        }
                                    };

                                    v7
                                };
                                Err(e)
                            }
                            _ => wit_bindgen::rt::invalid_enum_discriminant(),
                        }
                    }
                }
            }
            impl Crud {
                #[allow(unused_unsafe, clippy::all)]
                /// Check if the key exists in the store.
                ///
                /// If the key exists in the store, it returns `Ok(true)`. If the key does
                /// not exist in the store, it returns `Ok(false)`.
                ///
                /// If any other error occurs, it returns an `Err(error)`.
                pub fn exists(&self, key: &str) -> Result<bool, Error> {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, string::String, vec::Vec};
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([u8; 16]);
                        let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                        let vec0 = key;
                        let ptr0 = vec0.as_ptr() as i32;
                        let len0 = vec0.len() as i32;
                        let ptr1 = ret_area.as_mut_ptr() as i32;
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:keyvalue/crud@0.1.0")]
                        extern "C" {
                            #[link_name = "[method]crud.exists"]
                            fn wit_import(_: i32, _: i32, _: i32, _: i32);
                        }

                        #[cfg(not(target_arch = "wasm32"))]
                        fn wit_import(_: i32, _: i32, _: i32, _: i32) {
                            unreachable!()
                        }
                        wit_import((self).handle() as i32, ptr0, len0, ptr1);
                        let l2 = i32::from(*((ptr1 + 0) as *const u8));
                        match l2 {
                            0 => {
                                let e = {
                                    let l3 = i32::from(*((ptr1 + 4) as *const u8));

                                    wit_bindgen::rt::bool_lift(l3 as u8)
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l4 = i32::from(*((ptr1 + 4) as *const u8));
                                    use super::super::super::wasi::keyvalue::types::Error as V8;
                                    let v8 = match l4 {
                                        0 => V8::NoSuchStore,
                                        1 => V8::AccessDenied,
                                        n => {
                                            debug_assert_eq!(n, 2, "invalid enum discriminant");
                                            let e8 = {
                                                let l5 = *((ptr1 + 8) as *const i32);
                                                let l6 = *((ptr1 + 12) as *const i32);
                                                let len7 = l6 as usize;
                                                let bytes7 =
                                                    Vec::from_raw_parts(l5 as *mut _, len7, len7);

                                                wit_bindgen::rt::string_lift(bytes7)
                                            };
                                            V8::Other(e8)
                                        }
                                    };

                                    v8
                                };
                                Err(e)
                            }
                            _ => wit_bindgen::rt::invalid_enum_discriminant(),
                        }
                    }
                }
            }
            impl Crud {
                #[allow(unused_unsafe, clippy::all)]
                /// Get all the keys in the store. It returns a list of keys.
                ///
                /// Note that the keys are not guaranteed to be returned in any particular order.
                ///
                /// If the store is empty, it returns an empty list.
                ///
                /// MAY show an out-of-date list of keys if there are concurrent writes to the store.
                ///
                /// If any error occurs, it returns an `Err(error)`.
                pub fn list_keys(
                    &self,
                ) -> Result<wit_bindgen::rt::vec::Vec<wit_bindgen::rt::string::String>, Error>
                {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, string::String, vec::Vec};
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([u8; 16]);
                        let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                        let ptr0 = ret_area.as_mut_ptr() as i32;
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:keyvalue/crud@0.1.0")]
                        extern "C" {
                            #[link_name = "[method]crud.list-keys"]
                            fn wit_import(_: i32, _: i32);
                        }

                        #[cfg(not(target_arch = "wasm32"))]
                        fn wit_import(_: i32, _: i32) {
                            unreachable!()
                        }
                        wit_import((self).handle() as i32, ptr0);
                        let l1 = i32::from(*((ptr0 + 0) as *const u8));
                        match l1 {
                            0 => {
                                let e = {
                                    let l2 = *((ptr0 + 4) as *const i32);
                                    let l3 = *((ptr0 + 8) as *const i32);
                                    let base7 = l2;
                                    let len7 = l3;
                                    let mut result7 = Vec::with_capacity(len7 as usize);
                                    for i in 0..len7 {
                                        let base = base7 + i * 8;
                                        let e7 = {
                                            let l4 = *((base + 0) as *const i32);
                                            let l5 = *((base + 4) as *const i32);
                                            let len6 = l5 as usize;
                                            let bytes6 =
                                                Vec::from_raw_parts(l4 as *mut _, len6, len6);

                                            wit_bindgen::rt::string_lift(bytes6)
                                        };
                                        result7.push(e7);
                                    }
                                    wit_bindgen::rt::dealloc(base7, (len7 as usize) * 8, 4);

                                    result7
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l8 = i32::from(*((ptr0 + 4) as *const u8));
                                    use super::super::super::wasi::keyvalue::types::Error as V12;
                                    let v12 = match l8 {
                                        0 => V12::NoSuchStore,
                                        1 => V12::AccessDenied,
                                        n => {
                                            debug_assert_eq!(n, 2, "invalid enum discriminant");
                                            let e12 = {
                                                let l9 = *((ptr0 + 8) as *const i32);
                                                let l10 = *((ptr0 + 12) as *const i32);
                                                let len11 = l10 as usize;
                                                let bytes11 =
                                                    Vec::from_raw_parts(l9 as *mut _, len11, len11);

                                                wit_bindgen::rt::string_lift(bytes11)
                                            };
                                            V12::Other(e12)
                                        }
                                    };

                                    v12
                                };
                                Err(e)
                            }
                            _ => wit_bindgen::rt::invalid_enum_discriminant(),
                        }
                    }
                }
            }
        }
    }
}

#[cfg(target_arch = "wasm32")]
#[link_section = "component-type:trigger"]
#[doc(hidden)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 702] = [
    3, 0, 7, 116, 114, 105, 103, 103, 101, 114, 0, 97, 115, 109, 13, 0, 1, 0, 7, 192, 4, 1, 65, 2,
    1, 65, 8, 1, 66, 7, 4, 0, 5, 115, 116, 111, 114, 101, 3, 1, 1, 113, 3, 13, 110, 111, 45, 115,
    117, 99, 104, 45, 115, 116, 111, 114, 101, 0, 0, 13, 97, 99, 99, 101, 115, 115, 45, 100, 101,
    110, 105, 101, 100, 0, 0, 5, 111, 116, 104, 101, 114, 1, 115, 0, 4, 0, 5, 101, 114, 114, 111,
    114, 3, 0, 1, 1, 105, 0, 1, 106, 1, 3, 1, 2, 1, 64, 1, 10, 105, 100, 101, 110, 116, 105, 102,
    105, 101, 114, 115, 0, 4, 4, 0, 17, 91, 115, 116, 97, 116, 105, 99, 93, 115, 116, 111, 114,
    101, 46, 103, 101, 116, 1, 5, 3, 1, 25, 119, 97, 115, 105, 58, 107, 101, 121, 118, 97, 108,
    117, 101, 47, 116, 121, 112, 101, 115, 64, 48, 46, 49, 46, 48, 5, 0, 2, 3, 0, 0, 5, 115, 116,
    111, 114, 101, 2, 3, 0, 0, 5, 101, 114, 114, 111, 114, 1, 66, 27, 2, 3, 2, 1, 1, 4, 0, 5, 115,
    116, 111, 114, 101, 3, 0, 0, 2, 3, 2, 1, 2, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 2, 4, 0, 4,
    99, 114, 117, 100, 3, 1, 1, 104, 1, 1, 105, 4, 1, 64, 1, 5, 115, 116, 111, 114, 101, 5, 0, 6,
    4, 0, 17, 91, 115, 116, 97, 116, 105, 99, 93, 99, 114, 117, 100, 46, 111, 112, 101, 110, 1, 7,
    1, 104, 4, 1, 112, 125, 1, 107, 9, 1, 106, 1, 10, 1, 3, 1, 64, 2, 4, 115, 101, 108, 102, 8, 3,
    107, 101, 121, 115, 0, 11, 4, 0, 16, 91, 109, 101, 116, 104, 111, 100, 93, 99, 114, 117, 100,
    46, 103, 101, 116, 1, 12, 1, 106, 0, 1, 3, 1, 64, 3, 4, 115, 101, 108, 102, 8, 3, 107, 101,
    121, 115, 5, 118, 97, 108, 117, 101, 9, 0, 13, 4, 0, 16, 91, 109, 101, 116, 104, 111, 100, 93,
    99, 114, 117, 100, 46, 115, 101, 116, 1, 14, 1, 64, 2, 4, 115, 101, 108, 102, 8, 3, 107, 101,
    121, 115, 0, 13, 4, 0, 19, 91, 109, 101, 116, 104, 111, 100, 93, 99, 114, 117, 100, 46, 100,
    101, 108, 101, 116, 101, 1, 15, 1, 106, 1, 127, 1, 3, 1, 64, 2, 4, 115, 101, 108, 102, 8, 3,
    107, 101, 121, 115, 0, 16, 4, 0, 19, 91, 109, 101, 116, 104, 111, 100, 93, 99, 114, 117, 100,
    46, 101, 120, 105, 115, 116, 115, 1, 17, 1, 112, 115, 1, 106, 1, 18, 1, 3, 1, 64, 1, 4, 115,
    101, 108, 102, 8, 0, 19, 4, 0, 22, 91, 109, 101, 116, 104, 111, 100, 93, 99, 114, 117, 100, 46,
    108, 105, 115, 116, 45, 107, 101, 121, 115, 1, 20, 3, 1, 24, 119, 97, 115, 105, 58, 107, 101,
    121, 118, 97, 108, 117, 101, 47, 99, 114, 117, 100, 64, 48, 46, 49, 46, 48, 5, 3, 1, 64, 1, 5,
    105, 110, 112, 117, 116, 115, 0, 115, 4, 0, 5, 100, 111, 105, 110, 103, 1, 4, 4, 1, 30, 99,
    111, 109, 112, 111, 110, 101, 110, 116, 58, 99, 117, 115, 116, 111, 109, 47, 116, 114, 105,
    103, 103, 101, 114, 64, 48, 46, 49, 46, 48, 4, 0, 11, 13, 1, 0, 7, 116, 114, 105, 103, 103,
    101, 114, 3, 0, 0, 0, 16, 12, 112, 97, 99, 107, 97, 103, 101, 45, 100, 111, 99, 115, 0, 123,
    125, 0, 70, 9, 112, 114, 111, 100, 117, 99, 101, 114, 115, 1, 12, 112, 114, 111, 99, 101, 115,
    115, 101, 100, 45, 98, 121, 2, 13, 119, 105, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110,
    116, 6, 48, 46, 49, 56, 46, 50, 16, 119, 105, 116, 45, 98, 105, 110, 100, 103, 101, 110, 45,
    114, 117, 115, 116, 6, 48, 46, 49, 54, 46, 48,
];

#[inline(never)]
#[doc(hidden)]
#[cfg(target_arch = "wasm32")]
pub fn __link_section() {}
